<!DOCTYPE html>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="resources/test-helpers.sub.js"></script>
<script>
var worker_url = 'resources/empty-worker.js';

<<<<<<< HEAD
promise_test(function(t) {
    var scope = 'resources/scope/re-register-resolves-to-new-value';
    var registration;
||||||| merged common ancestors
async_test(function(t) {
    var scope = 'resources/scope/re-register-resolves-to-new-value';
    var registration;
=======
promise_test(async function(t) {
    const scope = 'resources/scope/re-register-resolves-to-new-value';
    const registration = await service_worker_unregister_and_register(t, worker_url, scope);
    t.add_cleanup(() => registration.unregister());
>>>>>>> upstream-releases

<<<<<<< HEAD
    return service_worker_unregister_and_register(t, worker_url, scope)
      .then(function(r) {
          t.add_cleanup(function() {
              return service_worker_unregister(t, scope);
            });

          registration = r;
          return wait_for_state(t, r.installing, 'activated');
        })
      .then(function() {
          return registration.unregister();
        })
      .then(function() {
          return navigator.serviceWorker.register(worker_url, { scope: scope });
        })
      .then(function(new_registration) {
          assert_not_equals(registration, new_registration,
                            'register should resolve to a new value');
        });
||||||| merged common ancestors
    service_worker_unregister_and_register(t, worker_url, scope)
      .then(function(r) {
          registration = r;
          return wait_for_state(t, r.installing, 'activated');
        })
      .then(function() {
          return registration.unregister();
        })
      .then(function() {
          return navigator.serviceWorker.register(worker_url, { scope: scope });
        })
      .then(function(new_registration) {
          assert_not_equals(registration, new_registration,
                            'register should resolve to a new value');
          service_worker_unregister_and_done(t, scope);
        })
      .catch(unreached_rejection(t));
=======
    await wait_for_state(t, registration.installing, 'activated');
    await registration.unregister();
    const newRegistration = await navigator.serviceWorker.register(worker_url, { scope });
    t.add_cleanup(() => newRegistration.unregister());

    assert_not_equals(
      registration, newRegistration,
      'register should resolve to a new value'
    );
>>>>>>> upstream-releases
  }, 'Unregister then register resolves to a new value');

<<<<<<< HEAD
promise_test(function(t) {
    var scope = 'resources/scope/re-register-while-old-registration-in-use';
    var registration;
||||||| merged common ancestors
async_test(function(t) {
    var scope = 'resources/scope/re-register-while-old-registration-in-use';
    var registration;
=======
promise_test(async function(t) {
  const scope = 'resources/scope/re-register-while-old-registration-in-use';
  const registration = await service_worker_unregister_and_register(t, worker_url, scope);
  t.add_cleanup(() => registration.unregister());
>>>>>>> upstream-releases

<<<<<<< HEAD
    return service_worker_unregister_and_register(t, worker_url, scope)
      .then(function(r) {
          t.add_cleanup(function() {
              return service_worker_unregister(t, scope);
            });

          registration = r;
          return wait_for_state(t, r.installing, 'activated');
        })
      .then(function() {
          return with_iframe(scope);
        })
      .then(function(frame) {
          return registration.unregister();
        })
      .then(function() {
          return navigator.serviceWorker.register(worker_url, { scope: scope });
        })
      .then(function(new_registration) {
          assert_equals(registration, new_registration,
                        'new registration should resolve to the same registration');
        });
  }, 'Unregister then register resolves to the original value if the ' +
         'registration is in use.');
||||||| merged common ancestors
    service_worker_unregister_and_register(t, worker_url, scope)
      .then(function(r) {
          registration = r;
          return wait_for_state(t, r.installing, 'activated');
        })
      .then(function() {
          return with_iframe(scope);
        })
      .then(function(frame) {
          return registration.unregister();
        })
      .then(function() {
          return navigator.serviceWorker.register(worker_url, { scope: scope });
        })
      .then(function(new_registration) {
          assert_equals(registration, new_registration,
                        'new registration should resolve to the same registration');
          service_worker_unregister_and_done(t, scope);
        })
      .catch(unreached_rejection(t));
  }, 'Unregister then register resolves to the original value if the ' +
         'registration is in use.');
=======
  await wait_for_state(t, registration.installing, 'activated');
  const frame = await with_iframe(scope);
  t.add_cleanup(() => frame.remove());
>>>>>>> upstream-releases

<<<<<<< HEAD
promise_test(function(t) {
    var scope = 'resources/scope/complete-unregistration-followed-by-' +
                'reloading-controllee-iframe';
    var registration;
    var frame;
    var service_worker;
    return service_worker_unregister_and_register(t, worker_url, scope)
      .then(function(r) {
          t.add_cleanup(function() {
              return service_worker_unregister(t, scope);
            });

          registration = r;
          return wait_for_state(t, r.installing, 'activated');
        })
      .then(function() {
          return with_iframe(scope);
        })
      .then(function(f) {
          frame = f;
          return registration.unregister();
        })
      .then(function() {
          return new Promise(function(resolve) {
              frame.onload = resolve;
              frame.contentWindow.location.reload();
            });
        })
      .then(function() {
          var c = frame.contentWindow.navigator.serviceWorker.controller;
          assert_equals(c, null, 'a page after unregistration should not be ' +
                                 'controlled by service worker');
          return navigator.serviceWorker.getRegistration(scope);
        })
      .then(function(r) {
          assert_equals(r, undefined, 'getRegistration should return ' +
                                      'undefined after unregistration');
        });
}, 'Reloading the last controlled iframe after unregistration should ensure ' +
   'the deletion of the registration');
||||||| merged common ancestors
async_test(function(t) {
    var scope = 'resources/scope/complete-unregistration-followed-by-' +
                'reloading-controllee-iframe';
    var registration;
    var frame;
    var service_worker;
    service_worker_unregister_and_register(t, worker_url, scope)
      .then(function(r) {
          registration = r;
          return wait_for_state(t, r.installing, 'activated');
        })
      .then(function() {
          return with_iframe(scope);
        })
      .then(function(f) {
          frame = f;
          return registration.unregister();
        })
      .then(function() {
          return new Promise(function(resolve) {
              frame.onload = resolve;
              frame.contentWindow.location.reload();
            });
        })
      .then(function() {
          var c = frame.contentWindow.navigator.serviceWorker.controller;
          assert_equals(c, null, 'a page after unregistration should not be ' +
                                 'controlled by service worker');
          return navigator.serviceWorker.getRegistration(scope);
        })
      .then(function(r) {
          assert_equals(r, undefined, 'getRegistration should return ' +
                                      'undefined after unregistration');
          service_worker_unregister_and_done(t, scope);
        })
      .catch(unreached_rejection(t));
}, 'Reloading the last controlled iframe after unregistration should ensure ' +
   'the deletion of the registration');
=======
  await registration.unregister();
  const newRegistration = await navigator.serviceWorker.register(worker_url, { scope });
  t.add_cleanup(() => newRegistration.unregister());

  assert_not_equals(
    registration, newRegistration,
    'Unregister and register should always create a new registration'
  );
}, 'Unregister then register does not resolve to the original value even if the registration is in use.');
>>>>>>> upstream-releases

promise_test(function(t) {
    var scope = 'resources/scope/re-register-does-not-affect-existing-controllee';
    var iframe;
    var registration;
    var controller;

    return service_worker_unregister_and_register(t, worker_url, scope)
      .then(function(r) {
<<<<<<< HEAD
          t.add_cleanup(function() {
              return service_worker_unregister(t, scope);
            });

||||||| merged common ancestors
=======
          t.add_cleanup(function() {
            return service_worker_unregister(t, scope);
          });

>>>>>>> upstream-releases
          registration = r;
          return wait_for_state(t, r.installing, 'activated');
        })
      .then(function() {
          return with_iframe(scope);
        })
      .then(function(frame) {
          iframe = frame;
          controller = iframe.contentWindow.navigator.serviceWorker.controller;
          return registration.unregister();
        })
      .then(function() {
          return navigator.serviceWorker.register(worker_url, { scope: scope });
        })
      .then(function(registration) {
          assert_equals(registration.installing, null,
                        'installing version is null');
          assert_equals(registration.waiting, null, 'waiting version is null');
          assert_equals(
              iframe.contentWindow.navigator.serviceWorker.controller,
              controller,
              'the worker from the first registration is the controller');
          iframe.remove();
        });
  }, 'Unregister then register does not affect existing controllee');

<<<<<<< HEAD
promise_test(function(t) {
    var scope = 'resources/scope/resurrection';
    var iframe;
    var registration;
||||||| merged common ancestors
async_test(function(t) {
    var scope = 'resources/scope/resurrection';
    var iframe;
    var registration;
=======
promise_test(async function(t) {
  const scope = 'resources/scope/resurrection';
  const altWorkerURL = worker_url + '?alt';
  const registration = await service_worker_unregister_and_register(t, worker_url, scope);
  t.add_cleanup(() => registration.unregister());
>>>>>>> upstream-releases

<<<<<<< HEAD
    return service_worker_unregister_and_register(t, worker_url, scope)
      .then(function(r) {
          t.add_cleanup(function() {
              return service_worker_unregister(t, scope);
            });

          registration = r;
          return wait_for_state(t, r.installing, 'activated');
        })
      .then(function() {
          return with_iframe(scope);
        })
      .then(function(frame) {
          iframe = frame;
          return registration.unregister();
        })
      .then(function() {
          return navigator.serviceWorker.register(worker_url, { scope: scope });
        })
      .then(function() {
          iframe.remove();
          return with_iframe(scope);
        })
      .then(function(frame) {
          assert_not_equals(
              frame.contentWindow.navigator.serviceWorker.controller, null,
              'document should have a controller');
          frame.remove();
        });
  }, 'Unregister then register resurrects the registration');
||||||| merged common ancestors
    service_worker_unregister_and_register(t, worker_url, scope)
      .then(function(r) {
          registration = r;
          return wait_for_state(t, r.installing, 'activated');
        })
      .then(function() {
          return with_iframe(scope);
        })
      .then(function(frame) {
          iframe = frame;
          return registration.unregister();
        })
      .then(function() {
          return navigator.serviceWorker.register(worker_url, { scope: scope });
        })
      .then(function() {
          iframe.remove();
          return with_iframe(scope);
        })
      .then(function(frame) {
          assert_not_equals(
              frame.contentWindow.navigator.serviceWorker.controller, null,
              'document should have a controller');
          frame.remove();
          service_worker_unregister_and_done(t, scope);
        })
      .catch(unreached_rejection(t));
  }, 'Unregister then register resurrects the registration');
=======
  await wait_for_state(t, registration.installing, 'activating');
  const iframe = await with_iframe(scope);
  t.add_cleanup(() => iframe.remove());

  await registration.unregister();
  const newRegistration = await navigator.serviceWorker.register(altWorkerURL, { scope });
  t.add_cleanup(() => newRegistration.unregister());

  assert_equals(newRegistration.active, null, 'Registration is new');

  await wait_for_state(t, newRegistration.installing, 'activating');

  const newIframe = await with_iframe(scope);
  t.add_cleanup(() => newIframe.remove());

  const iframeController = iframe.contentWindow.navigator.serviceWorker.controller;
  const newIframeController = newIframe.contentWindow.navigator.serviceWorker.controller;

  assert_not_equals(iframeController, newIframeController, 'iframes have different controllers');
}, 'Unregister then register does not resurrect the registration');
>>>>>>> upstream-releases
</script>
